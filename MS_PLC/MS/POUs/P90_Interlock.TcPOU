<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="P90_Interlock" Id="{c8b81d81-de46-4c7a-a894-4387b2cd9bf7}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P90_Interlock
VAR
	bRecipeRunning 		: BOOL;
	RecipeStopped 		: BOOL;
	ManualOperation 	: BOOL;
	bInductionHeaterMC	: BOOL;
	bThermalBathMC		: BOOL;
	bVacuumPumpMC 		: BOOL;
	bLineHeaterMC 		: BOOL; 

	bRecipeStartAvailable	: BOOL;
	bReactorOpenEnable		: BOOL;
	bHeaterOnEnable			: BOOL;
	bPumpOnEnable			: BOOL;
	
	bDorOnEnable			: BOOL;
	bDorOffEnable			: BOOL;
	bOpenEnableTemp			: BOOL;
	bOpenEnablePress		: BOOL;	
	
	bPowerResetSwitch		: BOOL;
	bMainPowerMonitor		: BOOL;

	AlarmTrig				: BOOL;
	WarningTrig				: BOOL;
	bMaintKey				: BOOL;
	bGasStateProcess		: BOOL;
	bGasStateSource			: BOOL;
	bGasStateVent			: BOOL;

	bPowerResetLED			: BOOL;
	bUPSMode				: BOOL;
	tAlarmDelay_A			: TIME; //아날로그 디바이스 지연시간
	tAlarmDelay_D			: TIME; //디지털 디바이스 지연시간
	
	fbDeviationCheck		:ARRAY[1..29] OF FB_DeviationCheck;
	wDeviceAlarmEnable		: DWORD;
	wDeviceWarningEnable	: DWORD;
	bDeviationAlarm			: BOOL;
	bDeviationWarning		: BOOL;
	wDeviationAlarm			: DWORD;
	wDeviationWarning		: DWORD;

	wLimitAlarmEnable		: DWORD;
	wLimitWarningEnable		: DWORD;
	bLimitAlarm				: BOOL;
	bLimitWarning			: BOOL;
	wLimitAlarm				: DWORD;
	wLimitWarning			: DWORD;
	
	wAlarmEnable			: DWORD;
	wWarningEnable			: DWORD;

	bFaultAlarm				: BOOL;
	bFaultWarning			: BOOL;
	wAlarm					: DWORD;
	wWarning				: DWORD;
		
	bAlarmEnable			: BOOL;
	bWarningEnable			: BOOL;
	bDeviceCurrentAlarmState	: BOOL;
	bDeviceCurrentWarningState 	: BOOL;
	fDeviceCurrentValue			: REAL;
	fDeviceAlarmTreshold		: REAL;
	fDeviceWarningTreshold		: REAL;
	
	i	: INT;
	j 	: INT;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Read from Device*)
//Interlock Variable Set
_DigitalInput();

//P90_Interlock
//jhkang bGasStateSource / 	bGasStateVent 정확한 의미 ? 
//Ansewer :3. bGasStateSource : Source gas 1개의 밸브가 열려있음. bGasStateVent : 모든 source가 vent 또는 close : 챔버 오픈 조건
bGasStateSource := F_StateAllValve();
bGasStateVent := F_State_All_Valve_Vent();


GVL_IO.aInterlock[1].10 := bRecipeStartAvailable;
GVL_IO.aInterlock[1].11 := bReactorOpenEnable;
//jhkang HeaterOn Enable 조건? 
//GVL_IO.aInterlock[1].12 := bHeaterOnEnable;
//jhkang Pump On Enable 조건?
//ANswer : 4, 5 챔버 오픈 조건 UI와 PLC 어디에서 활지 구분 필요,(기본적으로 PLC에서 모두 설정 후 UI에 넘겨줌)
GVL_IO.aInterlock[1].12 := bPumpOnEnable;

//알람 지연 시간 변환
tAlarmDelay_A := REAL_TO_TIME(GVL_IO.aInterlockSet[3]*1000); // UI Setting Analog Delay Time Value(Miliseconde)
tAlarmDelay_D := REAL_TO_TIME(GVL_IO.aInterlockSet[4]*1000); // UI Setting Analog Delay Time Value(Miliseconde)


//Controller Deviation Monitoring - MFC/EPC
IF bMaintKey THEN //bMaintKey 변경
	//매인터넌스 키가 ON 되었을 때 MC(Induction, Bath, Pump, L_Heater) 조작 허용
	GVL_IO.nCaseSignalTower	:= 4; //Signal Tower Blue - Maintenance
	
	GVL_COMMAND_FROM_UI.CMD_HEATER_MAIN_MC_ON := GVL_IO.aOutputCmd[1].0;
	GVL_COMMAND_FROM_UI.CMD_THERMAL_BACH_MC_ON:=GVL_IO.aOutputCmd[1].1;
	GVL_COMMAND_FROM_UI.CMD_VACUUM_PUMP_MC_ON:=GVL_IO.aOutputCmd[1].2;
	GVL_COMMAND_FROM_UI.CMD_LINE_HEATER_MC_ON:=GVL_IO.aOutputCmd[1].3;
ELSE
	_100_Alarm_Pressure_Low();
	_101_Alarm_MFC_EPC();
	_103_Alarm_Reactor_OverPre_Temp();
	_Alarm_Utility();	
	_Button_Reset_Warning();
	_Alarm_Utility_Parts();
END_IF

_01_Enable_RunRecipe();
_02_Enable_Reactor_Open();
_03_Enable_DOR_ON();
_04_Enable_Heater_ON();
_05_Enable_OpenPressure();
_06_Enable_OpenTemp();


(* Out to Device*)
GVL_IO.aDigitalOutputIO[3].7 := bPowerResetLED;
GVL_IO.aDigitalOutputIO[2].4 := bUPSMode;


]]></ST>
    </Implementation>
    <Action Name="_01_Enable_RunRecipe" Id="{d3eac737-19db-4a7f-9faa-c97873096da5}">
      <Implementation>
        <ST><![CDATA[	
 bRecipeStartAvailable := //레시피 가능한 상태이면 TRUE
 	(AlarmTrig = FALSE) AND
 	(WarningTrig = FALSE ) AND
 	(bMaintKey = FALSE ) AND
 	(GVL_IO_REACTOR_CABINET.DI_03_ReactorDoorDownLimitSensor = TRUE ) AND //Cover Lower Limt
 	(GVL_IO.aInputState[5].8) AND //DOR State
 	(RCP.userState <> 10) AND //Not Recipe Run State
 	(bGasStateProcess = FALSE ) AND //Safety Process Gas : TRUE
 	(bGasStateSource = FALSE ) AND //Safety Source Gas : TRUE
 	(bGasStateVent = FALSE ) AND
 	P11_E3508.bManAuto_E3508 AND //Temperature Controller Auto : True
 	P12_IQ_PLUS.ingPressureControl AND 
	GVL_IO_REACTOR_CABINET.DI_03_CylinderAutoSwitch_Closed = TRUE ; //Throttle Valve Pressure Control Mode : True 
 ]]></ST>
      </Implementation>
    </Action>
    <Action Name="_02_Enable_Reactor_Open" Id="{fd40fb3f-6f9b-44f1-ab24-bf988a26340f}">
      <Implementation>
        <ST><![CDATA[// DOR Off Conditions
//jhkang (GVL_IO.aInterlockEnable[1].3 = FALSE ) AND //Can Open Temperature Check
//왜 UI 에서 설정되는 Can OPen Temp / Pressure 를 확인 하는지 ? 
 
bDorOffEnable :=
	(AlarmTrig = FALSE) AND
	(GVL_IO.bDORState = FALSE) AND
	(RCP.userState <> 10) AND //Not Recipe Run State
	(bGasStateProcess = FALSE) AND //Safety Process Gas : TRUE
	(bGasStateSource = FALSE) AND //Safety Source Gas : TRUE
	bGasStateVent = TRUE AND //Vent Valve는 펌프 뒤쪽 Open
	(GVL_IO.aInterlockEnable[1].3 = FALSE ) AND //Can Open Temperature Check
	bOpenEnableTemp = TRUE AND
	(GVL_IO.aInterlockEnable[1].4 = FALSE ) AND //Can Open Pressure Check
	bOpenEnablePress ;
	

bReactorOpenEnable := bDorOffEnable;



]]></ST>
      </Implementation>
    </Action>
    <Action Name="_03_Enable_DOR_ON" Id="{9aa2df21-d253-4c98-a825-e11376eacac2}">
      <Implementation>
        <ST><![CDATA[//jhkang Dor ON 조건 다시 확인 필요
bDorOnEnable :=	(AlarmTrig = FALSE ) AND GVL_IO.isCoverClosed AND GVL_IO.bDorState AND GVL_IO.isPumpRunning;

GVL_IO.bDorOnEnable := bDorOnEnable;]]></ST>
      </Implementation>
    </Action>
    <Action Name="_04_Enable_Heater_ON" Id="{79ca0e4f-56e9-4d95-8d74-462d31bebf61}">
      <Implementation>
        <ST><![CDATA[bHeaterOnEnable := bDorOnEnable;]]></ST>
      </Implementation>
    </Action>
    <Action Name="_05_Enable_OpenPressure" Id="{6e95fe0e-f951-426e-903c-9832afe36f99}">
      <Implementation>
        <ST><![CDATA[IF  P12_IQ_PLUS.wCDG1_PV < GVL_IO.aInterlockSet[10] THEN  //Can Open Reactor Pressure
	bOpenEnablePress := TRUE;
ELSE
	bOpenEnablePress := FALSE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="_06_Enable_OpenTemp" Id="{98bf05bc-fd49-4f54-8490-b1f51f88199e}">
      <Implementation>
        <ST><![CDATA[//jhkang Can Open Temp 가 3508 온도 맞는지?
IF  P11_E3508.wE3508_PV < GVL_IO.aInterlockSet[9] THEN  // Can Open Temp
	bOpenEnableTemp := TRUE;
ELSE
	bOpenEnableTemp := FALSE;
END_IF

]]></ST>
      </Implementation>
    </Action>
    <Action Name="_100_Alarm_Pressure_Low" Id="{489a92bb-80c7-428c-bf86-308900773682}">
      <Implementation>
        <ST><![CDATA[//Gas Pressure Alarm N2, H2, H2S, H2Se
FOR i := 1 TO 4 DO
	wLimitAlarmEnable := SHR(GVL_IO.aInterlockEnable[4], (i-1)); 
	wLimitWarningEnable := SHR(GVL_IO.aInterlockEnable[5], (i-1));
	GVL_SEQUENCE.fbSensorLimitCheck[i](
		bAlarmEnable := wLimitAlarmEnable.0,  // Enable 
		bWarningEnable := wLimitWarningEnable.0,
		fCurrentValue := GVL_IO.aMonitoring_PV[(i+3)], // 현재 값 
		fAlarmTreshold := GVL_IO.aInterlockSet[5],
		fWarningTreshold := GVL_IO.aInterlockSet[6],
		tAlarmDelay := tAlarmDelay_D,
		bLimitAlarm => bLimitAlarm, //알람 출력
		bLimitWarning => bLimitWarning //주의(Warning) 출력
		);	
	IF bLimitAlarm THEN		
		GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
		GVL_IO.nCaseSignalTower := 1; // Signal Tower RED - Alarm
		//팝업 표시
		wLimitAlarm := ROR(GVL_IO.aInterlock[2], (i-1));
		wLimitAlarm.0 := TRUE;
		GVL_IO.aInterlock[2] := ROL(wLimitAlarm, (i-1));
		//대시보드 표시
		wLimitAlarm := ROR(GVL_IO.aInterlock[1], (i*2));
		wLimitAlarm.0 := TRUE;
		GVL_IO.aInterlock[1] := ROL(wLimitAlarm, (i*2));
	ELSE
		//팝업 표시
		wLimitAlarm := ROR(GVL_IO.aInterlock[2], (i-1));
		wLimitAlarm.0 := FALSE;
		GVL_IO.aInterlock[2] := ROL(wLimitAlarm, (i-1));
		//대시보드 표시
		wLimitAlarm := ROR(GVL_IO.aInterlock[1], (i*2));
		wLimitAlarm.0 := FALSE;
		GVL_IO.aInterlock[1] := ROL(wLimitAlarm, (i*2));
	END_IF
	
	IF bLimitWarning THEN		
		GVL_IO.aInterlock[1].1 := TRUE; //Warning Trig
		GVL_IO.nCaseSignalTower := 2; // Signal Tower YELLOW - Warning
		//팝업 표시
		wLimitWarning := ROR(GVL_IO.aInterlock[4], (i-1));
		wLimitWarning.0 := TRUE;
		GVL_IO.aInterlock[4] := ROL(wLimitWarning, (i-1));
		//대시보드 표시
		wLimitWarning := ROR(GVL_IO.aInterlock[1], (i*2)+1);
		wLimitWarning.0 := TRUE;
		GVL_IO.aInterlock[1] := ROL(wLimitWarning, (i*2)+1);
	ELSE
		//팝업 표시
		wLimitWarning := ROR(GVL_IO.aInterlock[4], (i-1));
		wLimitWarning.0 := FALSE;
		GVL_IO.aInterlock[4] := ROL(wLimitWarning, (i-1));
		//대시보드 표시
		wLimitWarning := ROR(GVL_IO.aInterlock[1], (i*2)+1);
		wLimitWarning.0 := FALSE;
		GVL_IO.aInterlock[1] := ROL(wLimitWarning, (i*2)+1);
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Action>
    <Action Name="_101_Alarm_MFC_EPC" Id="{8202243e-b333-45ee-ace8-e6ff9df10a7f}">
      <Implementation>
        <ST><![CDATA[//jhkang MFC ,EPC
FOR i := 1 TO 16 DO
		wDeviceAlarmEnable := SHR(GVL_IO.aInterlockEnable[2], (i+2)); //오늘쪽 쉬프트 연산
		wDeviceWarningEnable := SHR(GVL_IO.aInterlockEnable[3], (i+2));
		
		GVL_SEQUENCE.fbDeviationCheck[i](
			bAlarmEnable := wDeviceAlarmEnable.0,
			bWarningEnable := wDeviceWarningEnable.0,
			fCurrentValue := GVL_IO.aController_PV[i],
			fControlValue := GVL_IO.aController_CV[i],
			fMaxValue := GVL_IO.aMaxValueController[i],
			fAlarmTreshold := GVL_IO.aInterlockSet[1],
			fWarningTreshold := GVL_IO.aInterlockSet[2],
			tAlarmDelay := tAlarmDelay_A,
			bDeviationAlarm => bDeviationAlarm, //알람 출력
			bDeviationWarning => bDeviationWarning // 주의(Warning) 출력
			);
			
		IF bDeviationAlarm THEN
			GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
			GVL_IO.nCaseSignalTower := 1; // Signal Tower RED - Alarm
			wDeviationAlarm := ROR(GVL_IO.aInterlock[3], (i+2));
			wDeviationAlarm.0 := TRUE;
			GVL_IO.aInterlock[3] := ROL(wDeviationAlarm, (i+2));
		ELSE
			wDeviationAlarm := ROR(GVL_IO.aInterlock[3], (i+2));
			wDeviationAlarm.0 := FALSE;
			GVL_IO.aInterlock[3] := ROL(wDeviationAlarm, (i+2));	
		END_IF
		
		IF bDeviationWarning THEN
			GVL_IO.aInterlock[1].1 := TRUE; // Warning Trig
			GVL_IO.nCaseSignalTower := 2; // Signal Tower Yellow - Warning
			wDeviationWarning := ROR(GVL_IO.aInterlock[5], (i+2));
			wDeviationWarning.0 := TRUE;
			GVL_IO.aInterlock[5] := ROL(wDeviationWarning, (i+2));
		ELSE
			wDeviationWarning := ROR(GVL_IO.aInterlock[5], (i+2));
			wDeviationWarning.0 := FALSE;
			GVL_IO.aInterlock[5] := ROL(wDeviationWarning, (i+2));
		END_IF
	END_FOR]]></ST>
      </Implementation>
    </Action>
    <Action Name="_103_Alarm_Reactor_OverPre_Temp" Id="{f66dfa94-0ab4-41d0-adb0-a183715c7f0f}">
      <Implementation>
        <ST><![CDATA[
//Cooling Water Over Temperature, Susceptor Over Temperature, Reactor Over Pressure
FOR i := 17 TO 19 DO
	CASE i OF
		
		17: //Susceptor Over Temperature
			bAlarmEnable := GVL_IO.aInterlockEnable[3].0;
			bWarningEnable := GVL_IO.aInterlockEnable[2].0;
			//jhkang P11_E3508.wE3508_PV 맞는지 확인
			fDeviceCurrentValue := P11_E3508.wE3508_PV;
			fDeviceAlarmTreshold := GVL_IO.aInterlockSet[7];
			fDeviceWarningTreshold := (GVL_IO.aInterlockSet[7] - 20.0); //20도 아래에서 Warning 발생
		
		18: //Reactor Over Pressure Alarm
			bAlarmEnable := GVL_IO.aInterlockEnable[3].1;
			bWarningEnable := GVL_IO.aInterlockEnable[2].1;
			//jhkang P12_IQ_PLUS.wCDG1_PV
			fDeviceCurrentValue := P12_IQ_PLUS.wCDG1_PV;
			fDeviceAlarmTreshold := GVL_IO.aInterlockSet[8];
			fDeviceWarningTreshold := (GVL_IO.aInterlockSet[8] - 50.0); //50Torr 아래에서 Warning 발생
			
		19: //Rotation
			bAlarmEnable := GVL_IO.aInterlockEnable[3].2;
			bWarningEnable := GVL_IO.aInterlockEnable[2].2;
			fDeviceCurrentValue := GVL_IO.nRotation_Converted_PV;
			fDeviceAlarmTreshold := GVL_IO.aInterlockSet[1];
			fDeviceWarningTreshold := GVL_IO.aInterlockSet[2]; 
									
	END_CASE
	
	GVL_SEQUENCE.fbDeviationCheck[i](
			bAlarmEnable := wDeviceAlarmEnable.0,
			bWarningEnable := wDeviceWarningEnable.0,
			fCurrentValue := GVL_IO.aController_PV[i],
			fControlValue := GVL_IO.aController_CV[i],
			fMaxValue := GVL_IO.aMaxValueController[i],
			fAlarmTreshold := GVL_IO.aInterlockSet[1],
			fWarningTreshold := GVL_IO.aInterlockSet[2],
			tAlarmDelay := tAlarmDelay_A,
			bDeviationAlarm => bDeviationAlarm, //알람 출력
			bDeviationWarning => bDeviationWarning // 주의(Warning) 출력
			);
			
		IF bDeviationAlarm THEN
			GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
			GVL_IO.nCaseSignalTower := 1; // Signal Tower RED - Alarm
			wDeviationAlarm := ROR(GVL_IO.aInterlock[3], (i-17));
			wDeviationAlarm.0 := TRUE;
			GVL_IO.aInterlock[3] := ROL(wDeviationAlarm, (i-17));
		ELSE
			wDeviationAlarm := ROR(GVL_IO.aInterlock[3], (i-17));
			wDeviationAlarm.0 := FALSE;
			GVL_IO.aInterlock[3] := ROL(wDeviationAlarm, (i-17));	
		END_IF
		
		IF bDeviationWarning THEN
			GVL_IO.aInterlock[1].1 := TRUE; // Warning Trig
			GVL_IO.nCaseSignalTower := 2; // Signal Tower Yellow - Warning
			wDeviationWarning := ROR(GVL_IO.aInterlock[5], (i-17));
			wDeviationWarning.0 := TRUE;
			GVL_IO.aInterlock[5] := ROL(wDeviationWarning, (i-17));
		ELSE
			wDeviationWarning := ROR(GVL_IO.aInterlock[5], (i-17));
			wDeviationWarning.0 := FALSE;
			GVL_IO.aInterlock[5] := ROL(wDeviationWarning, (i-17));
		END_IF
	END_FOR]]></ST>
      </Implementation>
    </Action>
    <Action Name="_Alarm_Utility" Id="{2f8bb936-9007-4196-95d8-8b3b7512b562}">
      <Implementation>
        <ST><![CDATA[	//Device Fault Check - Pneumatic, Heater, Pump, Motor, GC Door, RC Door
	FOR i := 1 TO 7 DO
		CASE i OF
			1: //CDA Alarm Switch (Pneumatic)
				bAlarmEnable := GVL_IO.aInterlockEnable[4].6;
				bWarningEnable := GVL_IO.aInterlockEnable[5].6;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[1].3;
				bDeviceCurrentWarningState := GVL_IO.aInputState[1].3;
			2: //Cooling Water Switch
				bAlarmEnable := GVL_IO.aInterlockEnable[4].7;
				bWarningEnable := GVL_IO.aInterlockEnable[5].7;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[1].4;
				bDeviceCurrentWarningState := GVL_IO.aInputState[1].4;
			3: //Rotatin Motor Fault
				bAlarmEnable := GVL_IO.aInterlockEnable[4].8;
				bWarningEnable := GVL_IO.aInterlockEnable[5].8;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[1].7;
				bDeviceCurrentWarningState := GVL_IO.aInputState[1].7;
			4: //Vacuum Pump Fault
				bAlarmEnable := GVL_IO.aInterlockEnable[4].9;
				bWarningEnable := GVL_IO.aInterlockEnable[5].9;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[1].10;
				bDeviceCurrentWarningState := GVL_IO.aInputState[1].9;
			5: //Gas Cabinet Door Open
				bAlarmEnable := GVL_IO.aInterlockEnable[4].10;
				bWarningEnable := GVL_IO.aInterlockEnable[5].10;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[1].15;
				bDeviceCurrentWarningState := GVL_IO.aInputState[1].15;
			6: //Reactor Cabinet Door Open
				bAlarmEnable := GVL_IO.aInterlockEnable[4].11;
				bWarningEnable := GVL_IO.aInterlockEnable[5].11;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[1].13;
				bDeviceCurrentWarningState := GVL_IO.aInputState[1].13;
			7: //DOR Fault
				bAlarmEnable := GVL_IO.aInterlockEnable[4].12;
				bWarningEnable := GVL_IO.aInterlockEnable[5].12;
				
				IF (GVL_IO.nDorOperationError = 1) THEN
					bDeviceCurrentAlarmState := TRUE;
				ELSE
					bDeviceCurrentAlarmState := FALSE;
				END_IF
				IF (GVL_IO.nDorOperationError = 2) OR (GVL_IO.nDorOperationError = 3) THEN
					bDeviceCurrentWarningState := TRUE;
				ELSE
					bDeviceCurrentWarningState := FALSE;
				END_IF
		END_CASE

		GVL_SEQUENCE.fbFaultCheck[i](
			bAlarmEnable := bAlarmEnable,
			bWarningEnable := bWarningEnable,
			bCurrentAlarmState := bDeviceCurrentAlarmState,
			bCurrentWarningState := bDeviceCurrentWarningState,
			tAlarmDelay := tAlarmDelay_D,
			bAlarm => bFaultAlarm,
			bWarning => bFaultWarning
			);
			
		IF bFaultAlarm THEN
			GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
			GVL_IO.nCaseSignalTower := 1; // Signal Tower RED - Alarm
			//팝업 표시
			wAlarm := ROR(GVL_IO.aInterlock[2], (i+5));
			wAlarm.0 := TRUE;
			GVL_IO.aInterlock[2] := ROL(wAlarm, (i+5));
		END_IF
		IF bFaultWarning THEN
			GVL_IO.aInterlock[1].1 := TRUE; //Warning Trig
			GVL_IO.nCaseSignalTower := 2; // Signal Tower YELLOW - Warning
			//팝업 표시
			wAlarm := ROR(GVL_IO.aInterlock[4], (i+5));
			wAlarm.0 := TRUE;
			GVL_IO.aInterlock[4] := ROL(wAlarm, (i+5));
		END_IF
	END_FOR]]></ST>
      </Implementation>
    </Action>
    <Action Name="_Alarm_Utility_Parts" Id="{9a2dacee-2e4c-4b78-a14f-4fa3c303bb8d}">
      <Implementation>
        <ST><![CDATA[//SMPS,Circuit Power , Gas Detector ,
	FOR i := 1 TO 4 DO
		CASE i OF
			1: //SMPS
				bAlarmEnable := GVL_IO.aInterlockEnable[4].13;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[2].5 AND GVL_IO.aInputState[2].6 AND GVL_IO.aInputState[2].7 AND GVL_IO.aInputState[2].8;
			2: //Circuit Power
				bAlarmEnable := GVL_IO.aInterlockEnable[4].14;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[2].13 AND GVL_IO.aInputState[2].13 AND GVL_IO.aInputState[2].14 
										AND GVL_IO.aInputState[2].13 AND GVL_IO.aInputState[3].0 AND GVL_IO.aInputState[3].1 AND GVL_IO.aInputState[3].2;
				
		//GVL_IO.aInputState[2].13:= GVL_IO_GAS_CABINET.DI_02_RotationMotorCP;
		//GVL_IO.aInputState[2].14:= GVL_IO_GAS_CABINET.DI_02_CoverLiftMotorCP;
		//GVL_IO.aInputState[2].15:= GVL_IO_GAS_CABINET.DI_02_T_VCP;
		
		//GVL_IO.aInputState[3].0:= GVL_IO_GAS_CABINET.DI_03_GasDetectorCP;
		//GVL_IO.aInputState[3].1:= GVL_IO_GAS_CABINET.DI_03_CabinetLampsCP;
		//GVL_IO.aInputState[3].2:= GVL_IO_GAS_CABINET.DI_03_MFCPowerCP;

			3: //Gas Detector
				bAlarmEnable := GVL_IO.aInterlockEnable[4].15;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[3].11 AND GVL_IO.aInputState[3].12 AND GVL_IO.aInputState[3].13 AND GVL_IO.aInputState[3].14;
				

		//GVL_IO.aInputState[3].11:= GVL_IO_GAS_CABINET.DI_04_GasDetectorH2;
		//GVL_IO.aInputState[3].12:= GVL_IO_GAS_CABINET.DI_04_GasDetectorH2S;
		//GVL_IO.aInputState[3].13:= GVL_IO_GAS_CABINET.DI_04_GasDetectorH2Se;
		//GVL_IO.aInputState[3].14:= GVL_IO_GAS_CABINET.DI_04_FireSensor;
			4: // External Alarm
				bAlarmEnable := GVL_IO.aInterlockEnable[4].16;
				bDeviceCurrentAlarmState := GVL_IO.aInputState[3].14 AND GVL_IO.aInputState[3].15 AND GVL_IO.aInputState[4].0 AND GVL_IO.aInputState[4].1 AND GVL_IO.aInputState[4].2
														AND GVL_IO.aInputState[4].3 AND GVL_IO.aInputState[4].4;
				
						
		//GVL_IO.aInputState[3].14:= GVL_IO_GAS_CABINET.DI_04_FireSensor;
		//GVL_IO.aInputState[3].15 := GVL_IO_GAS_CABINET.DI_04_ExternalScrubberFault;
		//GVL_IO.aInputState[4].0 := GVL_IO_GAS_CABINET.DI_05_ExternalH2GasCabinetFault;
		//GVL_IO.aInputState[4].1 := GVL_IO_GAS_CABINET.DI_05_ExternalH2SGasCabinetFault;
		//GVL_IO.aInputState[4].2 := GVL_IO_GAS_CABINET.DI_05_ExternalH2SeGasCabinetFault;
		//GVL_IO.aInputState[4].3 := GVL_IO_GAS_CABINET.DI_05_ExternalUserInputAlarm;

		END_CASE

		GVL_SEQUENCE.fbFaultCheck_Utility[i](
			bAlarmEnable := bAlarmEnable,
			bWarningEnable := FALSE,
			bCurrentAlarmState := bDeviceCurrentAlarmState,
			bCurrentWarningState := FALSE,
			tAlarmDelay := tAlarmDelay_D,
			bAlarm => bFaultAlarm,
			bWarning => bFaultWarning
			);
			
		IF bFaultAlarm THEN
			GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
			GVL_IO.nCaseSignalTower := 1; // Signal Tower RED - Alarm
			//팝업 표시
			wAlarm := ROR(GVL_IO.aInterlock[2], (i+13));
			wAlarm.0 := TRUE;
			GVL_IO.aInterlock[2] := ROL(wAlarm, (i+13));
		END_IF
	END_FOR]]></ST>
      </Implementation>
    </Action>
    <Action Name="_Button_Reset_Warning" Id="{11672cb1-8009-4337-b6f3-945de947a9f8}">
      <Implementation>
        <ST><![CDATA[IF GVL_IO.aInterlockEnable[1].0 THEN //알람 리셋 버턴을 눌렀을 때
	GVL_IO.aInterlock[1].0 := FALSE; //Alarm Trig Reset
	GVL_IO.aInterlockEnable[1].0 := FALSE; //버턴 초기화
	GVL_IO.nCaseSignalTower := 4; // Signal Tower Blue - Idle
END_IF
IF GVL_IO.aInterlockEnable[1].1 THEN //주의 리셋 버턴을 눌렀을 때
	GVL_IO.aInterlock[1].1 := FALSE; //Warmomg Trig Reset
	GVL_IO.aInterlockEnable[1].1 := FALSE; //버턴 초기화
	GVL_IO.nCaseSignalTower := 4; // Signal Tower Blue - Idle
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="_DigitalInput" Id="{28df557a-761a-4b0f-8136-26acb753e00f}">
      <Implementation>
        <ST><![CDATA[bMaintKey := GVL_IO_REACTOR_CABINET.DI_01_MaintenanceModeKey;
bPowerResetSwitch := GVL_IO_GAS_CABINET.DI_01_ResetButton;
//jhkang Main Power Monitor 가 뭔가 ? 
//7. 순간정전 되었다가 전기가 다시 살아 났을 때,
// UPS는 전원이 살아있고, 히터, 펌프, bath는 전기가 나갔을 때 (아직 명확한 로직이 없음)
bMainPowerMonitor := GVL_IO.aDigitalInputIO[7].5; /// ??????? 이게 뭐지 ?]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="P90_Interlock">
      <LineId Id="1926" Count="54" />
      <LineId Id="415" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._01_Enable_RunRecipe">
      <LineId Id="2" Count="13" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._02_Enable_Reactor_Open">
      <LineId Id="2" Count="20" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._03_Enable_DOR_ON">
      <LineId Id="2" Count="2" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._04_Enable_Heater_ON">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._05_Enable_OpenPressure">
      <LineId Id="2" Count="3" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._06_Enable_OpenTemp">
      <LineId Id="2" Count="6" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._100_Alarm_Pressure_Low">
      <LineId Id="2" Count="56" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._101_Alarm_MFC_EPC">
      <LineId Id="2" Count="40" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._103_Alarm_Reactor_OverPre_Temp">
      <LineId Id="2" Count="21" />
      <LineId Id="25" Count="43" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._Alarm_Utility">
      <LineId Id="81" Count="74" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._Button_Reset_Warning">
      <LineId Id="12" Count="8" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="P90_Interlock._DigitalInput">
      <LineId Id="72" Count="4" />
      <LineId Id="71" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>